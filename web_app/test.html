<!DOCTYPE html>
<html>
<head>
    <title>TidyBib</title>
    <style>
        textarea {
            width: 45%;
            height: 400px;
            font-family: Courier, monospace;
        }

        #output {
            width: 45%;
            height: 400px;
            font-family: Courier, monospace;
            overflow: auto;
        }

        .keyword { color: blue; }
        .braces { color: orange; }
        .equal_sign { color: red; }
        .field { color: purple; }
        .value { color: green; }
    </style>
</head>
<body>
    <textarea id="input"></textarea>
    <textarea id="output" readonly></textarea><br>
    <button onclick="tidy()">Tidy</button>

    <script>
        function tidy() {
            const input = document.getElementById('input').value;
            const output = document.getElementById('output');

            // Parse BibTeX content
            const parsedEntries = parseBibTeX(input);

            // Format parsed entries
            let formattedContent = '';
            parsedEntries.forEach(entry => {
                formattedContent += `@${entry.type}{${entry.id},\n`;
                for (const key in entry.fields) {
                    formattedContent += `  ${key} = ${entry.fields[key]},\n`;
                }
                formattedContent += '}\n\n';
            });

            output.value = formattedContent;

            // Highlight BibTeX syntax
            highlightSyntax(output);
        }

        function parseBibTeX(bibtex) {
            const entries = [];
            const regex = /@(\w+){([^,]+),([\s\S]+?)}/g;
            let match;
            while ((match = regex.exec(bibtex)) !== null) {
                const type = match[1];
                const id = match[2];
                const fields = {};

                const fieldRegex = /(\w+)\s*=\s*{([^}]+)}/g;
                let fieldMatch;
                while ((fieldMatch = fieldRegex.exec(match[3])) !== null) {
                    const key = fieldMatch[1].trim();
                    const value = fieldMatch[2].trim();
                    fields[key] = value;
                }

                entries.push({ type, id, fields });
            }
            return entries;
        }

        function highlightSyntax(element) {
            const content = element.value;
            element.innerHTML = '';

            const keywordPattern = /@(\w+)|}|{|\b(?:author|title|booktitle|year|editor|volume|number|series|pages|doi|publisher|month|journal|address|edition|howpublished)\b/g;
            const bracesPattern = /[{}]/g;
            const equalSignPattern = /=/g;
            const fieldPattern = /\b(?:author|title|booktitle|year|editor|volume|number|series|pages|doi|publisher|month|journal|address|edition|howpublished)\b/g;
            const valuePattern = /{[^{}]*}/g;

            let match;
            while ((match = keywordPattern.exec(content)) !== null) {
                const className = match[1] ? 'keyword' : match[0] === '{' || match[0] === '}' ? 'braces' : match[0] === '=' ? 'equal_sign' : 'field';
                const span = document.createElement('span');
                span.classList.add(className);
                span.textContent = match[0];
                element.appendChild(span);
            }

            // Add value highlighting separately to avoid conflicts with braces and equal signs
            let lastIndex = 0;
            let valueMatch;
            while ((valueMatch = valuePattern.exec(content)) !== null) {
                const span = document.createElement('span');
                span.classList.add('value');
                span.textContent = valueMatch[0];
                element.appendChild(document.createTextNode(content.substring(lastIndex, valueMatch.index)));
                element.appendChild(span);
                lastIndex = valueMatch.index + valueMatch[0].length;
            }
            element.appendChild(document.createTextNode(content.substring(lastIndex)));
        }
    </script>
</body>
</html>
